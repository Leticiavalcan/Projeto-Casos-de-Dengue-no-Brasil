# -*- coding: utf-8 -*-
"""Projeto-semantix.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oig8DtwGDBmgEcb7oCTJEHvd7DZJNcuZ
"""

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.preprocessing import LabelEncoder
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix

"""DT_NOTIFIC, DT_SIN_PRI, DT_ENCERRA: datas importantes do caso.

SG_UF_NOT, ID_MUNICIP, ID_REGIONA: localização geográfica.

HISTOPA_N, IMUNOH_N: resultados laboratoriais.

HOSPITALIZ, CLASSI_FIN, EVOLUCAO: internação, diagnóstico e desfecho do caso.

TPAUTOCTO, COUFINF: origem e forma de infecção.
"""

df = pd.read_csv("/content/Dengue.csv")
print(df.head(5))

# Dimensão do dataset
print(df.shape)

# Informações gerais
print(df.info())

# Distribuição da variável alvo
print(df['CLASSI_FIN'].value_counts())  # Classe final: 1=Dengue, 2=Chikungunya, 3=Outros

# Verificando valores ausentes
missing = df.isnull().sum()
print(missing[missing > 0])

# Estatísticas descritivas
print(df.describe(include='all'))

date_cols = ['DT_NOTIFIC', 'DT_SIN_PRI', 'DT_NASC', 'DT_INVEST', 'DT_ENCERRA']
for col in date_cols:
    df[col] = pd.to_datetime(df[col], errors='coerce')

cat_cols = [
    'CS_SEXO', 'CS_GESTANT', 'CS_RACA', 'CS_ESCOL_N', 'FEBRE', 'MIALGIA', 'CEFALEIA', 'EXANTEMA',
    'VOMITO', 'NAUSEA', 'DOR_COSTAS', 'CONJUNTVIT', 'ARTRITE', 'ARTRALGIA', 'PETEQUIA_N',
    'LEUCOPENIA', 'LACO', 'DOR_RETRO', 'DIABETES', 'HEMATOLOG', 'HEPATOPAT', 'RENAL',
    'HIPERTENSA', 'ACIDO_PEPT', 'AUTO_IMUNE', 'RESUL_SORO', 'RESUL_NS1', 'RESUL_VI_N',
    'RESUL_PCR_', 'HISTOPA_N', 'IMUNOH_N', 'HOSPITALIZ', 'TPAUTOCTO', 'CLASSI_FIN', 'EVOLUCAO'
]

for col in cat_cols:
    df[col] = df[col].astype('category')

# Tratamento de valores ausentes
# Preenchimento: moda para categóricas, mediana para numéricas
for col in df.columns:
    if df[col].dtype.name == 'category':
        df[col] = df[col].fillna(df[col].mode()[0])
    elif df[col].dtype == 'float64' or df[col].dtype == 'int64':
        df[col] = df[col].fillna(df[col].median())

# Tratar valores nulos ou inválidos
df.replace(9.0, np.nan, inplace=True)  # 9 = ignorado
df = df.dropna(subset=["EVOLUCAO"])  # remover casos sem evolução

# Remover colunas que não contribuem para o modelo
df = df.drop(columns=["ID_AGRAVO", "ID_UNIDADE", "ID_REGIONA", "NU_ANO", "SEM_NOT", "SEM_PRI"])

# Codificar variáveis categóricas(one-hot encoding)
df = pd.get_dummies(df, columns=["SG_UF_NOT", "CLASSI_FIN"], drop_first=True)

# Definir variável alvo e features
target = "EVOLUCAO"
features = [col for col in df.columns if col not in ["EVOLUCAO", "DT_NOTIFIC", "DT_SIN_PRI", "DT_ENCERRA"]]

"""Análise Exploratória de Dados"""

# Distribuição do desfecho
sns.countplot(x="EVOLUCAO", data=df)
plt.title("Distribuição dos Desfechos dos Casos (EVOLUÇÃO)")
plt.xlabel("Evolução (1 = Cura, 2 = Óbito por Dengue, 3 = Óbito por Outras Causas)")
plt.ylabel("Número de Casos")
plt.show()

# Tempo até encerramento por evolução
sns.boxplot(x="EVOLUCAO", y="DT_ENCERRA", data=df)
plt.title("Tempo para Encerramento por Evolução")
plt.show()

# Correlação
corr = df[features + ["EVOLUCAO"]].corr()
plt.figure(figsize=(12, 8))
sns.heatmap(corr, annot=True, fmt=".2f", cmap="coolwarm")
plt.title("Mapa de Calor das Correlações")
plt.show()

"""Modelagem Preditiva (Random Forest)"""

# Garantir que colunas de data não entrem nas features
data_cols = ["DT_NOTIFIC", "DT_SIN_PRI", "DT_ENCERRA"]
target = "EVOLUCAO"
features = [col for col in df.columns if col not in data_cols + [target]]

# Separar X e y novamente
X = df[features]
y = df[target]

# Separar features e alvo
X = df[features]
y = df["EVOLUCAO"]

# Remover colunas datetime diretamente pois esta dando conflito ao rodar o modelo de treino
X = df[features].copy()
X = X.select_dtypes(exclude=["datetime", "datetimetz"])

# Verificar se sobrou alguma coluna datetime
print("Colunas com tipo datetime em X:", X.select_dtypes(include=["datetime"]))

# Divisão treino/teste
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, stratify=y, random_state=42
)

# Treinamento
model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# Avaliação
y_pred = model.predict(X_test)
print("Relatório de Classificação:\n", classification_report(y_test, y_pred))
print("Matriz de Confusão:\n", confusion_matrix(y_test, y_pred))

importances = pd.Series(model.feature_importances_, index=X.columns)

# Importância das features
importances = pd.Series(model.feature_importances_, index=X.columns)
importances.sort_values(ascending=True).tail(15).plot(kind="barh")
plt.title("Top 15 Variáveis Mais Importantes")
plt.xlabel("Importância")
plt.tight_layout()
plt.show()